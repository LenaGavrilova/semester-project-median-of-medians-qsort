#pragma once

#include <vector>

namespace itis {

    /**
   * Вычисление середины области, заданной левой и правой индексами.
   *
   * @param start - индекс левой границы (включительно)
   * @param stop - индекс правой границы (включительно)
   * @return индекс середины области
   */
    inline constexpr int middle_of(int start, int stop) {
        return start + (stop - start) / 2;
    }

    /**
     * Вычисление индекса медианы среди трех элементов массива.
     *
     * Медиана вычисляется среди трех элементов: началом, концом и серединой границы заданной области.
     * Середины области вычисляется функцией middle_of.
     *
     * @param arr - массив элементов
     * @param start - индекс начала границы области поиска медианы (включительно)
     * @param stop - индекс конца границы области поиска медианы (включительно)
     * @return индекс медианы среди трех элементов
     */
    int median_of_three(const std::vector<int> &arr, int start, int stop);

    /**
     * Разбиение массива в заданной области.
     *
     * Сложность по памяти ~ O(1).
     * Разбиение осуществляется строго в пределах заданной области.
     *
     * В реализации используется алгоритм Lomuto:
     *    1. Выбирается опорный элемент (pivot).
     *    2. Элементы меньше опорного передвигаются влево.
     *    3. Элементы больше или равные опорному передвигаются вправо.
     *
     * Перемещение элементов происходит непосредственно во входном массиве (не месте).
     *
     * В результате получается область массива, в котором слева от опорного элемента
     * все элементы меньше него, а справа - больше или равны.
     *
     * @param arr - массив элементов
     * @param start - индекс начала области разбиения (включительно)
     * @param stop - индекс конца области разбиения (включительно)
     * @param pivot - индекс опорного элемента в массиве (должен находится границах области разбиения)
     * @return индекс опорного элемента после совершения операции разбиения
     *
     * @see https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme (есть страница на русском)
     */
    int partition(std::vector<int> &arr, int start, int stop, int pivot);

    struct QuickSort final {

        /**
         * Реализация рекурсивного алгоритма быстрой сортировки (Quick Sort).
         *
         * Сложность ~ от O(n * log n) до O(n^2).
         * Элементы массива сортируются в порядке неубывания.
         *
         * Проблемы (для самостоятельного изучения):
         *  1. Массив со множеством повторяющихся элементов (проблема разбиения).
         *  2. Выбор опорного элемента: медиана (best), median of three, random, left/right/middle (worst).
         *  3. Скрытая сложность сортировки маленьких массивов (< 10-30 элементов).
         *
         * @param arr - массив элементов
         *
         * @see https://en.wikipedia.org/wiki/Quicksort (есть страница на русском)
         */
        void Sort(std::vector<int> &arr) const;

    private:
        /**
         * Вспомогательный метод для реализации быстрой сортировки.
         *
         * Алгоритм:
         *  0. Выход из рекурсии при start => stop.
         *  1. Выбор опорного элемента в области методом медианы из трех.
         *  2. Разбиение массива относительно опорного элемента (partitioning).
         *  3. Рекурсивный вызов метода для левой и правой областей.
         *
         * @param arr - массив элементов
         * @param start - индекс левой границы области сортировки (включительно)
         * @param stop - индекс правой границы области сортировки (включительно)
         */
        void quick_sort(std::vector<int> &arr, int start, int stop) const;
    };

}  // namespace itis
